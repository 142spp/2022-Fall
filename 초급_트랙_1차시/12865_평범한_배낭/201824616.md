# BOJ 12865 평범한 배낭
## 문제 풀이
배낭의 최대 무게와 물품의 수를 행과 열로 갖는 배열을 만들었습니다. 이를 이용한 동적 계획법을 사용하였습니다.

배낭의 최대 무게를 0부터 원래 값까지 가정했습니다. 물건의 무게가 현재 배낭의 무게보다 무거우면 배열 값을 이전 물건까지의 가치합 최댓값으로 설정했습니다.

```C++
    for (int i = 1; i <= N; i++) {
        cin >> W >> V;

        for (int j = 0; j <= K; j++) {
            if (W > j) arr[i][j] = arr[i - 1][j];
```

물건의 무게를 현재 배낭의 무게로 허용 가능하다면, 현재 물건을 넣지 않은 경우와 넣은 경우로 나눠 가치합 최댓값이 무엇인지 판단했습니다. 

```C++
            else arr[i][j] = max(arr[i - 1][j], arr[i - 1][j - W] + V);
```

이를 모든 물건에 대해 반복한 뒤에는, 배열의 마지막 값이 모든 물건의 가치합 최댓값이 되었습니다.
