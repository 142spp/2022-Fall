# BOJ 2502 떡 먹는 호랑이

마지막 날의 전 날을 변수 temp라고 생각하고, 각 날을 temp로 표현하였습니다.

각 날의 배열을 2개로 쪼개서, 하나는 정수를 저장하고 나머지 하나는 temp의 계수를 저장하였습니다.

마지막 날은 정수 부분이 K, 게수 0으로 표현 가능합니다. 마지막의 전 날은 정수 0, 계수 1로 표현 가능합니다.

```C++
    arr[0][0] = K;
    arr[1][0] = 0;
    arr[0][1] = 0;
    arr[1][1] = 1;
```

7번째 날이 K이고 6번째 날이 temp라면, 5번째 날과 6번째 날의 합이 K가 되어야 합니다. 따라서 5번째 날은 K - temp로 표현됩니다. 이를 모든 날에 대해 적용하였습니다.

```C++
    for (int i = 2; i < D; i++) {
        arr[0][i] = arr[0][i - 2] - arr[0][i - 1];
        arr[1][i] = arr[1][i - 2] - arr[1][i - 1];
    }
```

첫번째 날과 두번째 날의 값은 0보다 커야하므로, 부정방정식을 통해 temp의 범위를 알 수 있습니다. temp를 범위 근처의 최대값으로 설정해 주었습니다.

```C++
temp = max(abs(arr[0][D - 1] / arr[1][D - 1]), abs(arr[0][D - 2] / arr[1][D - 2]));
```

최대값에서부터 하나씩 줄여가며, 문제의 조건을 만족시키는 temp의 값을 찾았습니다.

```C++
    while (true) {
        int l = arr[0][D - 1] + (arr[1][D - 1] * temp);
        int r = arr[0][D - 2] + (arr[1][D - 2] * temp);

        if (l > 0 && r > 0 && l <= r) {
            cout << l << endl << r;
            break;
        }

        temp--;
    }
```
